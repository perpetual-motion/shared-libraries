const { readFile, writeFile } = require('fs/promises');
const { resolve } = require('path');

async function main() {
  const [interfaceFile, ...interfaces] = process.argv.slice(2);

  const source = resolve(__dirname, '..', interfaceFile);
  const destination = source.replace(/\.ts$/i, '.validator.ts');
  const content = (await readFile(source, 'utf-8')).replace(/`/g, '\\`');

  const cppStandards = content.match(/export\s*type\s*CppStandard\s*=\s*(.*);/)[1].split('|').map(each => each.replace(/'/g, '').trim());
  const cStandards = content.match(/export\s*type\s*CStandard\s*=\s*(.*);/)[1].split('|').map(each => each.replace(/'/g, '').trim());

  const q = (x) => typeof x === 'number' ? x : `'${x}'`;

  // generate validators for each specified interface 
  const validators = interfaces.map(iface => `export const validate${iface} = createValidator(code, '${iface}');`);

  // write out the file 
  await writeFile(destination, `/* eslint-disable header/header */
// ===========================================
// AUTOGENERATED VALIDATOR FILE. DO NOT EDIT.
// ===========================================

import { createValidator } from '@perpetual-motion/automation';
import { CppStandard, CStandard } from './interfaces';

const code = \`${content}\`;

${validators.join('\n\n')}

const cppStandards = new Map<string|number, CppStandard>([
  // strings
  ${cppStandards.map(each => `[${q(each)}, '${each}']`).join(', ')},
  ${cppStandards.map(each => `[${q(each).toUpperCase()}, '${each}']`).join(', ')},
  ${cppStandards.map(each => `[${q(each.substring(3))}, '${each}']`).join(', ')},
  ${cppStandards.map(each => `[${q(`gnu++${each.substring(3)}`)}, '${each}']`).join(', ')},
  ${cppStandards.map(each => `[${q(`gnu++${each.substring(3)}`).toUpperCase()}, '${each}']`).join(', ')},
  ${cppStandards.map(each => `[${q(Number(each.substring(3) < 88 ? 2000 + Number(each.substring(3)) : 1900 + Number(each.substring(3))).toString())}, '${each}']`).join(', ')},
  // numbers
  ${cppStandards.map(each => `[${Number(each.substring(3))}, '${each}']`).join(', ')},
  ${cppStandards.map(each => `[${Number(each.substring(3) < 88 ? 2000 + Number(each.substring(3)) : 1900 + Number(each.substring(3)))}, '${each}']`).join(', ')},
]);

// given a string or a number, return a valid CppStandard or undefined
export function toCppStandard(value: string|number|undefined|Array<any>): CppStandard|undefined {
  if (Array.isArray(value)) {
    value = value.flat(2)[0] as string|number|undefined;
  }
  return value ? cppStandards.get(value) || cppStandards.get(value.toString().substring(0,4)) : undefined;
}

const cStandards = new Map<string|number, CStandard>([
  // strings
  ${cStandards.map(each => `[${q(each)}, '${each}']`).join(', ')},
  ${cStandards.map(each => `[${q(each).toUpperCase()}, '${each}']`).join(', ')},
  ${cStandards.map(each => `[${q(each.substring(1))}, '${each}']`).join(', ')},
  ${cStandards.map(each => `[${q(`gnu${each.substring(1)}`)}, '${each}']`).join(', ')},
  ${cStandards.map(each => `[${q(`gnu${each.substring(1)}`).toUpperCase()}, '${each}']`).join(', ')},
  ${cStandards.map(each => `[${q(Number(each.substring(1) < 88 ? 2000 + Number(each.substring(1)) : 1900 + Number(each.substring(1))).toString())}, '${each}']`).join(', ')},
  // numbers
  ${cStandards.map(each => `[${Number(each.substring(1))}, '${each}']`).join(', ')},
  ${cStandards.map(each => `[${Number(each.substring(1) < 88 ? 2000 + Number(each.substring(1)) : 1900 + Number(each.substring(1)))}, '${each}']`).join(', ')},
]);

// given a string or a number, return a valid CStandard or undefined
export function toCStandard(value: string|number|undefined|Array<any>): CStandard|undefined {
  if (Array.isArray(value)) {
    value = value.flat(2)[0] as string|number|undefined;
  }
  return value ? cStandards.get(value) || cStandards.get(value.toString().substring(0,4)) : undefined;
}


`.trim(), 'utf-8');
}

main();