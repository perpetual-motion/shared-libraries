{
  "analysis": { 
    "custom-steps": [
      "handle-cl-environment", // very specific to msvc compilers - turn $env:CL and $env:_CL_ into command line args
      "read-response-files",  // read response files and insert command line args for the contents
      
    ],
    
    "compilerArgs": {
      // Engineered Reqex                 // what to apply to the toolset result
      "${-/}I(?<path>.+)" :               { "includePath": "${path}" },
      "${-/}I;(?<path>.+)" :              { "includePath": "${path}" },
      "${-/}FI(?<path>.+)" :              { "forceInclude": "${path}" },
      "${-/}FI;(?<path>.+)" :             { "forceInclude": "${path}" }, 
      "-include;(?<path>.+)" :            { "forceInclude": "${path}" }, // This support for passing "-include" to cl.exe can be removed in the future, when Unreal Engine is updated to no longer pass it to cl.exe.
      "${-/}external:I(?<path>.+)" :      { "systemInclude": "${path}" },
      "${-/}external:I;(?<path>.+)" :     { "systemInclude": "${path}" },
      "${-/}T[cC]" :                      { "is_c": true, "keep":true },
      "${-/}T[pP]" :                      { "is_c": false, "keep":true },
      "${-/}std:(?<std>.+)" :             { "keep": true },


      "${-/}D;${keyEqualsValue}" :        { "defines": { "${key}": "${value}" } },
      "${-/}D;${keyNoValue}" :            { "defines": { "${key}": "1" } },
      "${-/}D${keyEqualsValue}" :         { "defines": { "${key}": "${value}" } },
      "${-/}D${keyNoValue}" :             { "defines": { "${key}": "1" } },

      "${-/}Zc:__cplusplus" :             { "compilerArgs": "--ms_cplusplus_std_value" },
      "${-/}Zc:__cplusplus-" :            { "compilerArgs": "--no_ms_cplusplus_std_value" },
      "${-/}Zl" :                         { "defines": { "_VC_NODEFAULTLIB": "1" } },
      "${-/}Zp(?<alignment>1|2|4|8|16)" : { "compilerArgs": [ "--pack_alignment", "${alignment}" ] },
      "${-/}Zp(?<alignment>.+)":          { "warning": "unknown pack alignment ${alignment}", "compilerArgs": [ "--pack_alignment", "1" ] },

      

      "-sysroot=(?<value>.+)" :           { "current_sysroot" : "${value}",},

    },
  }
}


// when arg is XXX then apply { ...: ... }
// when arg is XXX and arg+1 is YYY then apply { ...: ... }
// when arg is XXX and arg+1 is YYY and arg+2 is ZZZ then apply { ...: ... }


// <engineered regex sequence> : <what to apply to TargetToolset>
// "engineered regex sequence" is a packed string that is semicolon separated regular expressions
// each regular expression will have '^'' and '$'' added to assume that a full argument must be matched
// tagged template literals (${}) are processed before anything else, ( which we can use for built-in macros)
// after that, the seqence of regular expressions is split
// when there are more than one, all of the regular expressions should match arguments in order (from the current arg)
// so "-D;(?<val>.*)" would be valid if a -D parameter was followed by anything.
// 
// the analysis phase is run, and the compiler args are run thru the list of the regular expressions
// if a match is found, the data is applied to the toolset block, and the args are consumed/dropped 
// (unless keep:true is in the apply block)
//
// Since they are run in order, the first match wins, and the args are consumed (unless 'keep:true' is specified).
// the compiler args runs the ordered set of 